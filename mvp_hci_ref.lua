-- This is the MVP lua script provided by daikang, 
-- which can be used directly for Qbox chiplet functional simulation

-- switchboard_cpu platform configuration
local function top()
    local info = debug.getinfo(2, "S").source
    if info:sub(1, 1) == "@" then
        info = info:sub(2)
    end
    local dir = info:match("(.*/)")
    if dir then
        return dir
    end
    return "./"
end

-- Base and Size
-- Qbox Space
local BOOTROM_BASE = 0x00000000
local BOOTROM_SIZE = 0x2000

local CLINT_BASE = 0x02004000
local CLINT_SIZE = 0x8000
local PLIC_BASE = 0x0C000000
local PLIC_SIZE = 0x400000
local RESET_BASE = 0x100000
local RESET_SIZE = 0x1000

-- Base, Size, IRQ for peripheral
-- Base and IRQ_ID may be automatically generated by "Translator"
-- User Space
local DRAM_BASE = 0x80000000
local DRAM_SIZE = 0x01000000 -- 16 MiB

local UART_BASE = 0x10000000
local UART_SIZE = 0x100

local SB_VADD_BASE = 0x30000000
local SB_VADD_SIZE = 0x1000
local SB_VADD_IRQ = 5
local SB_CUDA_BASE = 0x31000000
local SB_CUDA_SIZE = 0x1000
local SB_CUDA_IRQ = 6
local SB_SENSOR_BASE = 0x32000000
local SB_SENSOR_SIZE = 0x1000
local SB_SENSOR_IRQ = 7


platform = {
    moduletype = "Container";
    quantum_ns = 100000; -- 100 us global quantum

    router = {
        moduletype = "router";
    };

    bootrom = {
        moduletype = "gs_memory";
        target_socket = { address = BOOTROM_BASE, size = BOOTROM_SIZE, bind = "&router.initiator_socket" };
    };

    qemu_inst_mgr = {
        moduletype = "QemuInstanceManager";
    };

    qemu_inst = {
        moduletype = "QemuInstance";
        args = { "&platform.qemu_inst_mgr", "RISCV64" };
        tcg_mode = "MULTI";
        sync_policy = "multithread-unconstrained";
    };

    cpu_0 = {
        moduletype = "cpu_riscv64";
        args = { "&platform.qemu_inst", 0 };
        mem = { bind = "&router.target_socket" };
        reset = { bind = "&reset.reset" };
        reset_vector = 0x00000000;
    };

    clint = {
        moduletype = "riscv_aclint_mtimer";
        args = { "&platform.qemu_inst" };
        mem = { address = CLINT_BASE, size = , bind = "&router.initiator_socket" };
        timecmp_base = 0x0;
        time_base = 0x7ff8;
        provide_rdtime = true;
        aperture_size = 0x10000;
        num_harts = 1;
    };

    plic_0 = {
        moduletype = "plic_sifive";
        args = { "&platform.qemu_inst" };
        mem = { address = PLIC_BASE, size = PLIC_SIZE, bind = "&router.initiator_socket" };
        num_sources = 16;
        num_priorities = 7;
        priority_base = 0x0;
        pending_base = 0x1000;
        enable_base = 0x2000;
        enable_stride = 0x80;
        context_base = 0x200000;
        context_stride = 0x1000;
        aperture_size = 0x400000;
        hart_config = "MS";
    };

    reset = {
        moduletype = "sifive_test";
        args = { "&platform.qemu_inst" };
        target_socket = { address = RESET_BASE, size = RESET_SIZE, bind = "&router.initiator_socket" };
    };

    loader = {
        moduletype = "loader";
        initiator_socket = { bind = "&router.target_socket" };
        { bin_file = top() .. "fw/bootstub.bin", address = 0x00000000 };
        { bin_file = top() .. "fw/bootstub.bin", address = 0x00001000 };
        { elf_file = top() .. "fw/cpu_demo.elf" };
        reset = { bind = "&reset.reset" };
    };

    uart0 = {
        moduletype = "uart_16550";
        args = { "&platform.qemu_inst" };
        mem = { address = UART_BASE, size = UART_SIZE, bind = "&router.initiator_socket" };
        irq_out = { bind = "&plic_0.irq_in_1" };
        regshift = 2;
        baudbase = 3686400;
    };

    sb_vadd = {
        moduletype = "SbVaddBridge";
        target_socket = { address = SB_VADD_BASE, size = SB_VADD_SIZE, bind = "&router.initiator_socket" };
        irq = { bind = "&plic_0.irq_in_" .. tostring(SB_VADD_IRQ) };
        -- URIs using ipc:// are normalised to filesystem paths by the bridge/host helpers
        tx_uri = "ipc:///tmp/qbox_vadd_tx";
        rx_uri = "ipc:///tmp/qbox_vadd_rx";
        queue_capacity = 0;
        fresh_queue = false;
        max_rate = -1;
    };

    sb_cuda = {
        moduletype = "SbCudaBridge";
        target_socket = { address = SB_CUDA_BASE, size = SB_CUDA_SIZE, bind = "&router.initiator_socket" };
        irq = { bind = "&plic_0.irq_in_" .. tostring(SB_CUDA_IRQ) };
        tx_uri = "ipc:///tmp/qbox_cuda_tx";
        rx_uri = "ipc:///tmp/qbox_cuda_rx";
        queue_capacity = 0;
        fresh_queue = false;
        max_rate = -1;
    };

    sb_sensor = {
        moduletype = "SbSensorBridge";
        target_socket = { address = SB_SENSOR_BASE, size = , bind = "&router.initiator_socket" };
        irq = { bind = "&plic_0.irq_in_" .. tostring(SB_SENSOR_IRQ) };
        tx_uri = "ipc:///tmp/qbox_sensor_tx";
        rx_uri = "ipc:///tmp/qbox_sensor_rx";
        queue_capacity = 0;
        fresh_queue = false;
        max_rate = -1;
    };

    dram = {
        moduletype = "gs_memory";
        target_socket = { address = DRAM_BASE, size = DRAM_SIZE, bind = "&router.initiator_socket" };
    };
}
return platform
